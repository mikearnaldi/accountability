/**
 * IdentityRepository - Repository interface for UserIdentity entity persistence
 *
 * Uses Effect Context.Tag pattern for dependency injection.
 * All operations return Effect with typed errors.
 *
 * @module IdentityRepository
 */

import type * as Chunk from "effect/Chunk"
import * as Context from "effect/Context"
import type * as Effect from "effect/Effect"
import type * as Option from "effect/Option"
import type { UserIdentity, UserIdentityId, ProviderData } from "@accountability/core/authentication/UserIdentity"
import type { AuthUserId } from "@accountability/core/authentication/AuthUserId"
import type { AuthProviderType } from "@accountability/core/authentication/AuthProviderType"
import type { ProviderId } from "@accountability/core/authentication/ProviderId"
import type { HashedPassword } from "@accountability/core/authentication/HashedPassword"
import type { EntityNotFoundError, PersistenceError } from "../Errors/RepositoryError.ts"

/**
 * UserIdentityInsert - Data required to create a new UserIdentity
 *
 * Contains all fields needed for identity creation. The id and createdAt
 * are provided by the caller (typically generated by the service layer).
 */
export interface UserIdentityInsert {
  readonly id: UserIdentityId
  readonly userId: AuthUserId
  readonly provider: AuthProviderType
  readonly providerId: ProviderId
  readonly providerData: Option.Option<ProviderData>
  /**
   * Password hash for 'local' provider identities (optional for other providers)
   */
  readonly passwordHash?: HashedPassword
}

/**
 * UserIdentityUpdate - Data for updating an existing UserIdentity
 *
 * Only providerData can be updated - other fields are immutable identifiers.
 */
export interface UserIdentityUpdate {
  readonly providerData?: Option.Option<ProviderData>
}

/**
 * IdentityRepositoryService - Service interface for UserIdentity persistence
 *
 * Provides CRUD operations for UserIdentity entities with typed error handling.
 */
export interface IdentityRepositoryService {
  /**
   * Find an identity by its unique identifier
   *
   * @param id - The identity ID to search for
   * @returns Effect containing Option of UserIdentity (None if not found)
   */
  readonly findById: (
    id: UserIdentityId
  ) => Effect.Effect<Option.Option<UserIdentity>, PersistenceError>

  /**
   * Find all identities for a user
   *
   * @param userId - The user ID to search for
   * @returns Effect containing Chunk of UserIdentity
   */
  readonly findByUserId: (
    userId: AuthUserId
  ) => Effect.Effect<Chunk.Chunk<UserIdentity>, PersistenceError>

  /**
   * Find an identity by provider and provider ID
   *
   * @param provider - The authentication provider type
   * @param providerId - The ID within the provider
   * @returns Effect containing Option of UserIdentity (None if not found)
   */
  readonly findByProvider: (
    provider: AuthProviderType,
    providerId: ProviderId
  ) => Effect.Effect<Option.Option<UserIdentity>, PersistenceError>

  /**
   * Find an identity for a specific user and provider
   *
   * @param userId - The user ID to search for
   * @param provider - The authentication provider type
   * @returns Effect containing Option of UserIdentity (None if not found)
   */
  readonly findByUserAndProvider: (
    userId: AuthUserId,
    provider: AuthProviderType
  ) => Effect.Effect<Option.Option<UserIdentity>, PersistenceError>

  /**
   * Create a new identity
   *
   * @param identity - The identity data to create
   * @returns Effect containing the created UserIdentity
   */
  readonly create: (
    identity: UserIdentityInsert
  ) => Effect.Effect<UserIdentity, PersistenceError>

  /**
   * Update an existing identity
   *
   * @param id - The identity ID to update
   * @param data - The fields to update
   * @returns Effect containing the updated UserIdentity
   * @throws EntityNotFoundError if identity doesn't exist
   */
  readonly update: (
    id: UserIdentityId,
    data: UserIdentityUpdate
  ) => Effect.Effect<UserIdentity, EntityNotFoundError | PersistenceError>

  /**
   * Delete an identity by its ID
   *
   * @param id - The identity ID to delete
   * @returns Effect containing void on success
   */
  readonly delete: (
    id: UserIdentityId
  ) => Effect.Effect<void, PersistenceError>

  /**
   * Delete all identities for a user
   *
   * @param userId - The user ID whose identities to delete
   * @returns Effect containing the number of deleted records
   */
  readonly deleteByUserId: (
    userId: AuthUserId
  ) => Effect.Effect<number, PersistenceError>

  /**
   * Get the password hash for a local provider identity
   *
   * Used by LocalAuthProvider to verify user passwords during authentication.
   * Only applicable for identities with provider='local'.
   *
   * @param provider - The authentication provider type
   * @param providerId - The ID within the provider (email for local auth)
   * @returns Effect containing Option of HashedPassword (None if not found or no hash)
   */
  readonly getPasswordHash: (
    provider: AuthProviderType,
    providerId: ProviderId
  ) => Effect.Effect<Option.Option<HashedPassword>, PersistenceError>

  /**
   * Update the password hash for a local provider identity
   *
   * Used to change a user's password. Only applicable for identities with provider='local'.
   *
   * @param provider - The authentication provider type
   * @param providerId - The ID within the provider (email for local auth)
   * @param newPasswordHash - The new hashed password
   * @returns Effect containing void on success
   * @throws EntityNotFoundError if identity doesn't exist
   */
  readonly updatePasswordHash: (
    provider: AuthProviderType,
    providerId: ProviderId,
    newPasswordHash: HashedPassword
  ) => Effect.Effect<void, EntityNotFoundError | PersistenceError>
}

/**
 * IdentityRepository - Context.Tag for dependency injection
 *
 * Usage:
 * ```typescript
 * import { IdentityRepository } from "@accountability/persistence/Services/IdentityRepository"
 *
 * const program = Effect.gen(function* () {
 *   const repo = yield* IdentityRepository
 *   const identity = yield* repo.findById(identityId)
 *   // ...
 * })
 * ```
 */
export class IdentityRepository extends Context.Tag("IdentityRepository")<
  IdentityRepository,
  IdentityRepositoryService
>() {}
