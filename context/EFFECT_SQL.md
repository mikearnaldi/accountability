# Effect SQL Best Practices

This document covers patterns for using `@effect/sql` with PostgreSQL.

## Use Schema to Decode SQL Results (Not Interfaces)

**Never use TypeScript interfaces or type parameters for SQL row types** - use Schema to get both type safety AND runtime validation.

```typescript
// WRONG - using interface for row type (no runtime validation)
interface AccountRow {
  id: string
  name: string
  account_type: string
}
const rows = yield* sql<AccountRow>`SELECT * FROM accounts`

// WRONG - using type parameter on sql (banned by lint rule: local/no-sql-type-parameter)
const rows = yield* sql<{ count: string }>`SELECT COUNT(*) as count FROM accounts`  // LINT ERROR

// CORRECT - use Schema to decode results
const AccountRow = Schema.Struct({
  id: AccountId,
  name: Schema.String,
  account_type: AccountType
})

// Use SqlSchema for type-safe queries with automatic decoding
const findById = SqlSchema.findOne({
  Request: AccountId,
  Result: AccountRow,
  execute: (id) => sql`SELECT * FROM accounts WHERE id = ${id}`
})

const account = yield* findById(accountId)  // Effect<Option<AccountRow>, ParseError, SqlClient>
```

## SqlSchema Patterns

```typescript
import { SqlSchema } from "@effect/sql"

// findOne - returns Option (0 or 1 result)
const findById = SqlSchema.findOne({
  Request: Schema.String,
  Result: AccountSchema,
  execute: (id) => sql`SELECT * FROM accounts WHERE id = ${id}`
})

// findAll - returns Array (0 or more results)
const findByCompany = SqlSchema.findAll({
  Request: CompanyId,
  Result: AccountSchema,
  execute: (companyId) => sql`SELECT * FROM accounts WHERE company_id = ${companyId}`
})

// single - expects exactly 1 result (fails if 0 or >1)
const getById = SqlSchema.single({
  Request: AccountId,
  Result: AccountSchema,
  execute: (id) => sql`SELECT * FROM accounts WHERE id = ${id}`
})

// void - for INSERT/UPDATE/DELETE with no return
const deleteById = SqlSchema.void({
  Request: AccountId,
  execute: (id) => sql`DELETE FROM accounts WHERE id = ${id}`
})
```

## Model.Class for Repository Entities

For full CRUD operations, use `Model.Class` which provides automatic schema variants:

```typescript
import { Model } from "@effect/sql"

class Account extends Model.Class<Account>("Account")({
  id: Model.Generated(AccountId),      // Generated by DB, not required for insert
  name: Schema.String,
  accountType: AccountType,
  createdAt: Model.DateTimeInsert,     // Auto-set on insert
  updatedAt: Model.DateTimeUpdate      // Auto-set on update
}) {}

// Model.Class provides these automatically:
// Account          - select schema (all fields)
// Account.insert   - insert schema (without generated/auto fields)
// Account.update   - update schema (for updates)
// Account.json     - JSON API schema
```

## SQL Helper Methods

```typescript
// Insert single or multiple rows
sql`INSERT INTO accounts ${sql.insert({ name, accountType })}`
sql`INSERT INTO accounts ${sql.insert([row1, row2, row3])}`

// Update with specific columns
sql`UPDATE accounts SET ${sql.update({ name, accountType })} WHERE id = ${id}`

// IN clause (handles empty array safely)
sql`SELECT * FROM accounts WHERE id IN ${sql.in(ids)}`

// Combine conditions
sql`SELECT * FROM accounts WHERE ${sql.and([
  sql`company_id = ${companyId}`,
  sql`active = true`
])}`
```

## Transform Row to Domain Object (Pure Function)

When mapping DB rows to domain objects, use a pure function - don't wrap in Effect:

```typescript
// WRONG - unnecessary Effect wrapping
const toAccount = (row: AccountRow): Effect.Effect<Account> =>
  Effect.try(() => Account.make({ ... }))

// CORRECT - pure function for transformation
const toAccount = (row: AccountRow): Account =>
  Account.make({
    id: row.id,
    name: row.name,
    accountType: row.account_type
  })

// Use in query
const accounts = yield* sql`SELECT * FROM accounts`
return accounts.map(toAccount)  // Just map, no Effect needed
```

## Error Handling in Repositories

```typescript
// WRONG - catchAllCause catches defects (bugs)
const wrapError = <A, E, R>(effect: Effect.Effect<A, E, R>) =>
  Effect.catchAllCause(effect, (cause) =>
    Effect.fail(new PersistenceError({ cause: Cause.squash(cause) }))
  )

// CORRECT - use mapError to transform only expected errors
const wrapError = <A, E, R>(effect: Effect.Effect<A, E, R>) =>
  Effect.mapError(effect, (error) =>
    new PersistenceError({ cause: error })
  )
```

## Transaction Patterns

```typescript
// Using sql.withTransaction for atomic operations
const createAccountWithAudit = (account: Account) =>
  Effect.gen(function* () {
    const sql = yield* SqlClient.SqlClient

    return yield* sql.withTransaction(
      Effect.gen(function* () {
        // Insert account
        yield* sql`INSERT INTO accounts ${sql.insert(account)}`

        // Insert audit log
        yield* sql`INSERT INTO audit_log ${sql.insert({
          entity_type: "account",
          entity_id: account.id,
          action: "create"
        })}`

        // Return the created account
        return account
      })
    )
  })
```

## Connection Pooling

The `@effect/sql-pg` package handles connection pooling automatically. You don't need to manage connections manually:

```typescript
// The SqlClient handles pooling - just use it directly
const findAccount = (id: AccountId) =>
  Effect.gen(function* () {
    const sql = yield* SqlClient.SqlClient

    // Connection is automatically acquired and released
    const rows = yield* sql`SELECT * FROM accounts WHERE id = ${id}`
    return rows[0]
  })
```

## Migrations

Run migrations at application startup or use a dedicated migration tool:

```typescript
// Simple migration runner
const runMigrations = Effect.gen(function* () {
  const sql = yield* SqlClient.SqlClient

  yield* sql`
    CREATE TABLE IF NOT EXISTS accounts (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      account_type TEXT NOT NULL,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    )
  `
})

// Run before starting the app
const program = runMigrations.pipe(
  Effect.flatMap(() => startServer)
)
```
